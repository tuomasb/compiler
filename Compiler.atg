import fi.tkk.cs.tkkcc.slx.CommandWord;

COMPILER SLXProject

CodeGenerator gen;
SymbolTable tab;

public void d(String dbgString) {
  System.out.println(dbgString);
}

CHARACTERS
  letter = 'A'..'Z' + 'a'..'z'.
  digit = '0'..'9'.

/*
   While more tokens could be defined such as assignment ':=' , and '&&', or if,
   I'll specify them in the parser as literals to keep my EBNF productions
   looking similar as in the original assignment. Productions will be easier to read.
*/

TOKENS
  identifier = letter {letter | digit}. /* Identifier must start with a letter to prevent ambiguity */
  integer = digit { digit }. /* Negative numbers not possible in grammar. Also Interger size check implemented later in parser */

IGNORE '\n' + '\r' /* Ignore LF CR */


PRODUCTIONS


SLXProject
=
MainFuncDecl
.


MainFuncDecl
=
"main" FuncBody (. gen.emit(CommandWord.HLT); .)
.


FuncBody
=
'{' VarDecl StatementList ReturnStatement '}'
.


VarDecl (. String ident; int type; .)
=
[Type<out type> 
Ident<out ident> (. tab.NewObj(ident, type); d("Added object: " + ident); d(String.valueOf(type)); .)
';' VarDecl]
.

/* Return value on top of the stack */
ReturnStatement (. int type; .)
=
"return" Expr<out type> ';'
.


StatementList
=
[Statement StatementList]
.


Statement (. Obj a; String ident; int type; .)
=
"if" '(' Expr<out type> ')' (. if(type!=2) SemErr("boolean type required"); gen.emit(CommandWord.ENT, 1); gen.emit(CommandWord.REQ); gen.emit(CommandWord.JZE, gen.lab); .)
"then"
Statement (. gen.emit(CommandWord.JMP, gen.lab + 1); .) /* Jump over else Statement to end */
"else" (. gen.emit(CommandWord.LAB, gen.lab); .)
Statement "fi" (. gen.emit(CommandWord.LAB, gen.lab); .) /* End of if statement */
| "repeat" Statement "until" '(' Expr<out type> ')' ';'
| "print" '(' Expr<out type> ')' ';' (. gen.emit(CommandWord.WRI); .)
| '{' StatementList '}'
| IdAccess<out ident> ":=" Expr<out type> ';' (. d("Searching for: " + ident); a = tab.FindObj(ident); gen.emit(CommandWord.ENT, a.adr); gen.emit(CommandWord.STM); .)
.


/* Different operations and type checking for them. Leave result on top of the stack */
Expr<out int type> (. int type2, type3; String op; type = 0; .)
=
(BaseExpr<out type2> [Operation<out op> BaseExpr<out type3> (.
  if(type2 != type3) SemErr("Incompatible types: " +  ((type2==1) ? "integer" : "boolean") + " and " + ((type3==1) ? "integer" : "boolean"));
  /* Emulate && with 1==(a==b) */
  if(op.equals("&&")) { gen.emit(CommandWord.REQ); gen.emit(CommandWord.ENT, 1); gen.emit(CommandWord.REQ); type = 2; }
  if(op.equals("<")) { gen.emit(CommandWord.RLT); type = 2; }
  if(op.equals(">")) { gen.emit(CommandWord.RGT); type = 2; }
  if(op.equals("+")) { gen.emit(CommandWord.ADD); type = 1; }
  if(op.equals("-")) { gen.emit(CommandWord.SUB); type = 1; }
.) ]
| '!' BaseExpr<out type2>)
.


Operation<out String op> (. op = "undef"; .)
=
"&&" (. op = t.val; d("Operation: " + op.toString()); .) 
| '<' (. op = t.val; d("Operation: " + op.toString()); .) 
| '>' (. op = t.val; d("Operation: " + op.toString()); .)
| '+' (. op = t.val; d("Operation: " + op.toString()); .)
| '-' (. op = t.val; d("Operation: " + op.toString()); .)
.


BaseExpr<out int type> (. int a, type2; Obj b; String ident; type = 0; .)
=
'(' Expr<out type2> ')'
| IdAccess<out ident> (. b = tab.FindObj(ident); type = b.type; gen.emit(CommandWord.ENT, b.adr); gen.emit(CommandWord.LDM); .)
| integer (. a = Integer.parseInt(t.val); type = 1; gen.emit(CommandWord.ENT, a); .)
| "true" (. gen.emit(CommandWord.ENT, 1); type = 2; .)
| "false" (. gen.emit(CommandWord.ENT, 0); type = 2; .)
| "read" '(' ')' (. gen.emit(CommandWord.REA); type = 1; .)
.

/* IdAccess is for fetching identifiers from memory but we will generate the VM intructions at a later time
   so until now we only need to bring out the name of the ID */
IdAccess<out String ident>
=
identifier (. ident = t.val; d("Id access: " + t.val); .)
.

/* Type declaration, undefined = 0, integer = 1, boolean = 2
   originally represented these with enum but it resulted in ugly code */
Type<out int type> (. type = 0; .)
= 
"int" (. type = 1; .)
| "boolean" (. type = 2; .)
.


/* Ident for variable declaration. Separate production for clarity. Need to bring out the name of the declared
   variable and then Initialize it in upper productions (VarDecl production) */
Ident<out String ident>
=
identifier (. ident = t.val; d("Id declare: " + t.val); .)
.


END SLXProject.
